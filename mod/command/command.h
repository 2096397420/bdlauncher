#include <MC.h>
#include <cmdhelper.h>

#include <type_traits>
#include <string_view>
#include <string>
#include <vector>
#include <memory>

/**
 * @brief Custom Command Mod
 *
 * Use codegen for command register
 */
namespace BDL::CustomCommand {

/**
 * \defgroup Interface API Interface
 * @{
 */

/**
 * @brief Custom Command Context
 *
 * Used for codegen
 */
class CustomCommandContext {
  ::CommandOrigin const *origin;
  ::CommandOutput *output;

  CustomCommandContext(CustomCommandContext const &) = delete;
  CustomCommandContext(CustomCommandContext &&)      = delete;

protected:
  /**
   * @brief PLEASE JUST CALL IT IN YOUR CONSTRUCTOR
   *
   * @param origin CommandOrigin
   * @param output CommandOutput
   */
  CustomCommandContext(CommandOrigin const &origin, CommandOutput &output) noexcept
      : origin(&origin), output(&output) {}

  // TODO: add more interface
};

/**
 * @brief Dynamic enum, can be changed in any time.
 *
 * @tparam Derived The real DynEnum class
 */
template <typename Derived> class CustomDynEnum {
  std::string_view value;

protected:
  /**
   * @brief Construct a new Custom Dyn Enum object
   *
   * @param value The enum value
   */
  CustomDynEnum(std::string_view value) : value(value) {}

public:
  /**
   * @brief get value
   *
   * @return std::string_view
   */
  inline operator std::string_view() noexcept {return value};
};

/**
 * @brief Parameter type proxy
 *
 * @tparam RealType
 */
template <typename RealType> class CommandParameterProxy;

class CustomCommandRegistry;

/**
 * @brief Dynamic Enum Controller
 *
 * @tparam DynEnum The target
 */
template <typename DynEnum> class CustomDynEnumHandle {
  static_assert(std::is_base_of_v<CustomDynEnum<DynEnum>, DynEnum>);
  friend class CustomCommandRegistry;
  CustomCommandRegistry *registry;

  CustomDynEnumHandle(CustomCommandRegistry *registry) noexcept : registry(registry) {}

public:
  /**
   * @brief add value to dynamic enum
   *
   * @param value the value
   */
  void addValue(std::string_view value) noexcept; // TODO: implement

  /**
   * @brief del value to dynamic enum
   *
   * @param value
   */
  void delValue(std::string_view value) noexcept; // TODO: implement

  /**
   * @brief clear dynamic enum
   */
  void clear() noexcept; // TODO: implement
};

/**
 * @brief The registry
 */
class CustomCommandRegistry {
  class Application {
    virtual void apply(::CommandRegistry *registry) = 0;
    virtual ~Application() {}
  };

  template <typename DynEnum> friend class CustomDynEnumHandle;
  ::CommandRegistry *vanilla;
  std::vector<std::unique_ptr<Application>> applications;

public:
  /**
   * @brief Enum registering application
   *
   * @tparam Enum Target enum
   */
  template <typename Enum> class EnumApplication : Application {
    std::string name;
    inline EnumApplication(std::string_view name) : name(name) {}
    EnumApplication(EnumApplication const &) = delete;
    EnumApplication(EnumApplication &&)      = delete;
    virtual void apply(::CommandRegistry *registry) override; // TODO

  public:
    /**
     * @brief Add value to enum
     *
     * @param name name
     * @param value value
     */
    void addValue(std::string_view name, Enum value); // TODO
  };

  /**
   * @brief Dynamic Enum Application
   *
   * @tparam DynEnum The target
   */
  template <typename DynEnum> class CustomDynEnumApplication : Application {
    static_assert(std::is_base_of_v<CustomDynEnum<DynEnum>, DynEnum>);
    EnumApplication(EnumApplication const &) = delete;
    EnumApplication(EnumApplication &&)      = delete;
    virtual void apply(::CommandRegistry *registry) override; // TODO
  };

  /**
   * @brief Command registering application
   *
   * @tparam Desc The command description class
   */
  template <typename Desc> class CommandApplication : Application {
    inline CommandApplication() {}
    CommandApplication(CommandApplication const &) = delete;
    CommandApplication(CommandApplication &&)      = delete;
    virtual void apply(::CommandRegistry *registry) override; // TODO

  public:
    /**
     * @brief Register command overload
     *
     * @tparam Overload Target overload class (will be generated by codegen)
     * @tparam T Argument definitions' type
     * @param args Argument definitions
     */
    template <typename Overload, typename... T> void registerOverload(T... args); // TODO
  };

  /**
   * @brief Get the Instance object
   *
   * @return CustomCommandRegistry& instance
   */
  static CustomCommandRegistry &getInstance(); // Note: implemented in cpp

  /**
   * @brief Starting registering
   *
   * Should not be call in user land
   *
   * @param registry Vanilla Command Registry
   */
  void startRegister(::CommandRegistry *registry); // Note: implemented in cpp

  /**
   * @brief Register dynamic enum
   *
   * @tparam DynEnum Target dynamic enum type
   * @return CustomDynEnumHandle<DynEnum> The dynamic handle
   */
  template <typename DynEnum>
  std::enable_if_t<std::is_base_of_v<CustomDynEnum<DynEnum>, CustomDynEnumHandle<DynEnum>>> registerDynEnum() {
    auto obj = std::make_unique<CustomDynEnumApplication<DynEnum>>();
    applications.push_back(obj);
    return {this};
  }

  /**
   * @brief Register static enum
   *
   * @tparam Enum Target static enum type
   * @param name Target enum name
   * @return EnumApplication<Enum> Enum registering application
   */
  template <typename Enum> EnumApplication<Enum> &registerEnum(std::string_view name) {
    auto obj = std::make_unique<EnumApplication<Enum>>(name);
    auto ret = obj.get();
    applications.push_back(obj);
    return *ret;
  }

  /**
   * @brief Register command
   *
   * @tparam Desc CommandDescription type
   * @return CommandApplication<Desc> Command registering application
   */
  template <typename Desc> CommandApplication<Desc> &registerCommand() {
    auto obj = std::make_unique<CommandApplication<Desc>>();
    auto ret = obj.get();
    applications.push_back(obj);
    return *ret;
  }
};

/** @} */

/**
 * \defgroup Private Private implemention details
 * @{
 */

/** @} */

} // namespace BDL::CustomCommand